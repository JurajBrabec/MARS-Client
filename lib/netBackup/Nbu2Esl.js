const cli = require("pixl-cli");
const debug = require("debug");
const fs = require("fs");
const moment = require("moment");
const { Command } = require("../Command");

class Nbu2Esl extends Command {
  constructor(netBackup) {
    super();
    this.netBackup = netBackup;
    this.fileName = "esl_omni_obcheck.txt";
    this.fileNameClients = "esl_omni_obcheck_client.txt";
    this.path = process.env.NBU2ESL_PATH;
    this.title = "Writing ESL information";
    this.line1 = "#Automatic upload for backup information to ESL";
    this.line2 = "#Generated by MARS 4.1 @";
    this.eslFields = {
      "System Name": "",
      "Backup Method": "NetBackup",
      "Backup Name": "",
      "Backup Scheduler": "NetBackup",
      "Tape Check Time": "15:00",
      "Backup Start Time": "",
      "Backup Type": "",
      "Service Tier": "98%",
      "Scheduling Mon": "",
      "Scheduling Tue": "",
      "Scheduling Wed": "",
      "Scheduling Thu": "",
      "Scheduling Fri": "",
      "Scheduling Sat": "",
      "Scheduling Sun": "",
      "Scheduling On Demand": "1",
      "Restartable?": "Auto Recovery",
      "Restart Window": "12 h",
      "Backup Device": "",
      "Backup Retention": "",
      "Recovery Instructions": "",
      Comments: "",
      //			,'Ticket Postpone Time'	: ''
      //			,'Backup Reportable'		: '1'
    };
    this.eslFieldsClients = {
      "System Name": "",
      "Backup Method": "NetBackup",
      "Backup Name": "",
      "Client System Name": "",
    };

    this.dbg = debug("nbu2esl");
  }
  onError = (error) => {
    this.status.error = error;
    this.throwError(error);
  };
  onResult = (result) => {
    this.status.commands = 1;
    this.status.rows = result.rows;
    this.status.duration = result.duration;
    this.status.sqlDuration = result.duration;
    this.status.sqls = result.sqls;
    this.status.warnings = result.warnings;
    this.status.errors = result.errors;
    if (result.errors) this.status.messages = result.messages;
    result = this.status;
    this.successEnd(result);
  };
  async toDatabase(database) {
    const startTime = moment(this.netBackup.startTime);
    let result;
    try {
      let sql, fileName, fields;
      if (!fs.existsSync(this.path)) {
        fs.mkdirSync(this.path);
      }
      sql = `select * from nbu_esl where masterserver='${this.netBackup.masterServer}';`;
      const result = await database.execute(sql);
      result.sqlDuration = (moment() - startTime) / 1000;
      if (result.rows) {
        fields = this.eslFields;
        fileName = this.path + "/" + this.fileName;
        if (fs.existsSync(fileName)) fs.unlinkSync(fileName);
        cli.appendFile(
          fileName,
          this.line1 + "\n" + this.line2 + startTime.format("D.M.Y H:mm") + "\n"
        );
        cli.appendFile(fileName, Object.keys(fields).join(",") + "\n");
        result.rows.forEach((row) => {
          fields["System Name"] = row.masterserver;
          fields["Backup Name"] = row.name;
          fields["Backup Start Time"] = row.mon_start || row.sun_start;
          fields["Backup Type"] = row.backuptype == "Full" ? "Full" : "Incr";
          fields["Scheduling Mon"] = row.mon_start ? 1 : 0;
          fields["Scheduling Tue"] = row.tue_start ? 1 : 0;
          fields["Scheduling Wed"] = row.wed_start ? 1 : 0;
          fields["Scheduling Thu"] = row.thu_start ? 1 : 0;
          fields["Scheduling Fri"] = row.fri_start ? 1 : 0;
          fields["Scheduling Sat"] = row.sat_start ? 1 : 0;
          fields["Scheduling Sun"] = row.sun_start ? 1 : 0;
          fields["Backup Device"] = row.res;
          fields["Backup Retention"] = row.retentionlevel.replace(
            /(ay|eek|onth|ear)s?/,
            ""
          );
          cli.appendFile(
            fileName,
            Object.values(fields)
              .map((value) => `"${value}"`)
              .join(",") + "\n"
          );
        });
        result.rows = result.rows.length;
        sql = `select * from nbu_esl_client where masterserver='${this.netBackup.masterServer}';`;
        const resultClients = await database.execute(sql);
        result.errors += resultClients.errors;
        result.warnings += resultClients.warnings;
        result.sqls++;
        result.sqlDuration += (moment() - startTime) / 1000;
        if (resultClients.rows) {
          fields = this.eslFieldsClients;
          fileName = this.path + "/" + this.fileNameClients;
          if (fs.existsSync(fileName)) fs.unlinkSync(fileName);
          cli.appendFile(
            fileName,
            this.line1 +
              "\n" +
              this.line2 +
              startTime.format("D.M.Y H:mm") +
              "\n"
          );
          cli.appendFile(fileName, Object.keys(fields).join(",") + "\n");
          resultClients.rows.forEach((row) => {
            fields["System Name"] = row.masterserver;
            fields["Backup Name"] = row.name;
            fields["Client System Name"] = row.client;
            cli.appendFile(
              fileName,
              Object.values(fields)
                .map((value) => `"${value}"`)
                .join(",") + "\n"
            );
          });
          result.rows += resultClients.rows.length;
        }
      }
      result.duration = (moment() - startTime) / 1000;
      this.onResult(result);
    } catch (err) {
      cli.warn(cli.red(`Error: ${err.message}\n`));
      this.onError(err);
    }
    return this.status;
  }
  test() {
    const result = {
      source: this.constructor.name,
      status: undefined,
    };

    return new Promise((resolve, reject) => {
      fs.exists(this.path, (exists) => {
        if (exists) {
          result.status = "OK";
          resolve(result);
        } else {
          result.error = err.code;
          result.status = err.message;
          resolve(result);
        }
      });
    });
  }
}

module.exports = { Nbu2Esl };
